{"mappings":"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","sources":["vendor/angular-route.js"],"sourcesContent":["/**\n * @license AngularJS v1.8.2\n * (c) 2010-2020 Google LLC. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\n/* global shallowCopy: true */\n\n/**\n * Creates a shallow copy of an object, an array or a primitive.\n *\n * Assumes that there are no proto properties for objects.\n */\nfunction shallowCopy(src, dst) {\n  if (isArray(src)) {\n    dst = dst || [];\n\n    for (var i = 0, ii = src.length; i < ii; i++) {\n      dst[i] = src[i];\n    }\n  } else if (isObject(src)) {\n    dst = dst || {};\n\n    for (var key in src) {\n      if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst || src;\n}\n\n/* global routeToRegExp: true */\n\n/**\n * @param {string} path - The path to parse. (It is assumed to have query and hash stripped off.)\n * @param {Object} opts - Options.\n * @return {Object} - An object containing an array of path parameter names (`keys`) and a regular\n *     expression (`regexp`) that can be used to identify a matching URL and extract the path\n *     parameter values.\n *\n * @description\n * Parses the given path, extracting path parameter names and a regular expression to match URLs.\n *\n * Originally inspired by `pathRexp` in `visionmedia/express/lib/utils.js`.\n */\nfunction routeToRegExp(path, opts) {\n  var keys = [];\n\n  var pattern = path\n    .replace(/([().])/g, '\\\\$1')\n    .replace(/(\\/)?:(\\w+)(\\*\\?|[?*])?/g, function(_, slash, key, option) {\n      var optional = option === '?' || option === '*?';\n      var star = option === '*' || option === '*?';\n      keys.push({name: key, optional: optional});\n      slash = slash || '';\n      return (\n        (optional ? '(?:' + slash : slash + '(?:') +\n        (star ? '(.+?)' : '([^/]+)') +\n        (optional ? '?)?' : ')')\n      );\n    })\n    .replace(/([/$*])/g, '\\\\$1');\n\n  if (opts.ignoreTrailingSlashes) {\n    pattern = pattern.replace(/\\/+$/, '') + '/*';\n  }\n\n  return {\n    keys: keys,\n    regexp: new RegExp(\n      '^' + pattern + '(?:[?#]|$)',\n      opts.caseInsensitiveMatch ? 'i' : ''\n    )\n  };\n}\n\n/* global routeToRegExp: false */\n/* global shallowCopy: false */\n\n// `isArray` and `isObject` are necessary for `shallowCopy()` (included via `src/shallowCopy.js`).\n// They are initialized inside the `$RouteProvider`, to ensure `window.angular` is available.\nvar isArray;\nvar isObject;\nvar isDefined;\nvar noop;\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for AngularJS apps.\n *\n * ## Example\n * See {@link ngRoute.$route#examples $route} for an example of configuring and using `ngRoute`.\n *\n */\n/* global -ngRouteModule */\nvar ngRouteModule = angular.\n  module('ngRoute', []).\n  info({ angularVersion: '1.8.2' }).\n  provider('$route', $RouteProvider).\n  // Ensure `$route` will be instantiated in time to capture the initial `$locationChangeSuccess`\n  // event (unless explicitly disabled). This is necessary in case `ngView` is included in an\n  // asynchronously loaded template.\n  run(instantiateRoute);\nvar $routeMinErr = angular.$$minErr('ngRoute');\nvar isEagerInstantiationEnabled;\n\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n * @this\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#examples $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  isArray = angular.isArray;\n  isObject = angular.isObject;\n  isDefined = angular.isDefined;\n  noop = angular.noop;\n\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|Function)=}` – Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs` – `{string=}` – An identifier name for a reference to the controller.\n   *      If present, the controller will be published to scope under the `controllerAs` name.\n   *    - `template` – `{(string|Function)=}` – html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `template` or `templateUrl` is required.\n   *\n   *    - `templateUrl` – `{(string|Function)=}` – path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *      One of `templateUrl` or `template` is required.\n   *\n   *    - `resolve` - `{Object.<string, Function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired.\n   *      For easier access to the resolved dependencies from the template, the `resolve` map will\n   *      be available on the scope of the route, under `$resolve` (by default) or a custom name\n   *      specified by the `resolveAs` property (see below). This can be particularly useful, when\n   *      working with {@link angular.Module#component components} as route templates.<br />\n   *      <div class=\"alert alert-warning\">\n   *        **Note:** If your scope already contains a property with this name, it will be hidden\n   *        or overwritten. Make sure, you specify an appropriate name for this property, that\n   *        does not collide with other properties on the scope.\n   *      </div>\n   *      The map object is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|Function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `resolveAs` - `{string=}` - The name under which the `resolve` map will be available on\n   *      the scope of the route. If omitted, defaults to `$resolve`.\n   *\n   *    - `redirectTo` – `{(string|Function)=}` – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.url()`. If the function throws an error, no further processing will\n   *      take place and the {@link ngRoute.$route#$routeChangeError $routeChangeError} event will\n   *      be fired.\n   *\n   *      Routes that specify `redirectTo` will not have their controllers, template functions\n   *      or resolves called, the `$location` will be changed to the redirect url and route\n   *      processing will stop. The exception to this is if the `redirectTo` is a function that\n   *      returns `undefined`. In this case the route transition occurs as though there was no\n   *      redirection.\n   *\n   *    - `resolveRedirectTo` – `{Function=}` – a function that will (eventually) return the value\n   *      to update {@link ng.$location $location} URL with and trigger route redirection. In\n   *      contrast to `redirectTo`, dependencies can be injected into `resolveRedirectTo` and the\n   *      return value can be either a string or a promise that will be resolved to a string.\n   *\n   *      Similar to `redirectTo`, if the return value is `undefined` (or a promise that gets\n   *      resolved to `undefined`), no redirection takes place and the route transition occurs as\n   *      though there was no redirection.\n   *\n   *      If the function throws an error or the returned promise gets rejected, no further\n   *      processing will take place and the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event will be fired.\n   *\n   *      `redirectTo` takes precedence over `resolveRedirectTo`, so specifying both on the same\n   *      route definition, will cause the latter to be ignored.\n   *\n   *    - `[reloadOnUrl=true]` - `{boolean=}` - reload route when any part of the URL changes\n   *      (including the path) even if the new URL maps to the same route.\n   *\n   *      If the option is set to `false` and the URL in the browser changes, but the new URL maps\n   *      to the same route, then a `$routeUpdate` event is broadcasted on the root scope (without\n   *      reloading the route).\n   *\n   *    - `[reloadOnSearch=true]` - `{boolean=}` - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and the URL in the browser changes, then a `$routeUpdate`\n   *      event is broadcasted on the root scope (without reloading the route).\n   *\n   *      <div class=\"alert alert-warning\">\n   *        **Note:** This option has no effect if `reloadOnUrl` is set to `false`.\n   *      </div>\n   *\n   *    - `[caseInsensitiveMatch=false]` - `{boolean=}` - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = shallowCopy(route);\n    if (angular.isUndefined(routeCopy.reloadOnUrl)) {\n      routeCopy.reloadOnUrl = true;\n    }\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      {originalPath: path},\n      path && routeToRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] === '/')\n            ? path.substr(0, path.length - 1)\n            : path + '/';\n\n      routes[redirectPath] = angular.extend(\n        {originalPath: path, redirectTo: path},\n        routeToRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === 'string') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#eagerInstantiationEnabled\n   * @kind function\n   *\n   * @description\n   * Call this method as a setter to enable/disable eager instantiation of the\n   * {@link ngRoute.$route $route} service upon application bootstrap. You can also call it as a\n   * getter (i.e. without any arguments) to get the current value of the\n   * `eagerInstantiationEnabled` flag.\n   *\n   * Instantiating `$route` early is necessary for capturing the initial\n   * {@link ng.$location#$locationChangeStart $locationChangeStart} event and navigating to the\n   * appropriate route. Usually, `$route` is instantiated in time by the\n   * {@link ngRoute.ngView ngView} directive. Yet, in cases where `ngView` is included in an\n   * asynchronously loaded template (e.g. in another directive's template), the directive factory\n   * might not be called soon enough for `$route` to be instantiated _before_ the initial\n   * `$locationChangeSuccess` event is fired. Eager instantiation ensures that `$route` is always\n   * instantiated in time, regardless of when `ngView` will be loaded.\n   *\n   * The default value is true.\n   *\n   * **Note**:<br />\n   * You may want to disable the default behavior when unit-testing modules that depend on\n   * `ngRoute`, in order to avoid an unexpected request for the default route's template.\n   *\n   * @param {boolean=} enabled - If provided, update the internal `eagerInstantiationEnabled` flag.\n   *\n   * @returns {*} The current value of the `eagerInstantiationEnabled` flag if used as a getter or\n   *     itself (for chaining) if used as a setter.\n   */\n  isEagerInstantiationEnabled = true;\n  this.eagerInstantiationEnabled = function eagerInstantiationEnabled(enabled) {\n    if (isDefined(enabled)) {\n      isEagerInstantiationEnabled = enabled;\n      return this;\n    }\n\n    return isEagerInstantiationEnabled;\n  };\n\n\n  this.$get = ['$rootScope',\n               '$location',\n               '$routeParams',\n               '$q',\n               '$injector',\n               '$templateRequest',\n               '$sce',\n               '$browser',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce, $browser) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as defined in the route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     *     The `locals` will be assigned to the route scope's `$resolve` property. You can override\n     *     the property name, using `resolveAs` in the route definition. See\n     *     {@link ngRoute.$routeProvider $routeProvider} for more info.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name=\"$route-service\" module=\"ngRouteExample\"\n     *          deps=\"angular-route.js\" fixBase=\"true\">\n     *   <file name=\"index.html\">\n     *     <div ng-controller=\"MainController\">\n     *       Choose:\n     *       <a href=\"Book/Moby\">Moby</a> |\n     *       <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n     *       <a href=\"Book/Gatsby\">Gatsby</a> |\n     *       <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n     *       <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name=\"book.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name=\"chapter.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name=\"script.js\">\n     *     angular.module('ngRouteExample', ['ngRoute'])\n     *\n     *      .controller('MainController', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller('BookController', function($scope, $routeParams) {\n     *          $scope.name = 'BookController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller('ChapterController', function($scope, $routeParams) {\n     *          $scope.name = 'ChapterController';\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when('/Book/:bookId', {\n     *         templateUrl: 'book.html',\n     *         controller: 'BookController',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when('/Book/:bookId/ch/:chapterId', {\n     *         templateUrl: 'chapter.html',\n     *         controller: 'ChapterController'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name=\"protractor.js\" type=\"protractor\">\n     *     it('should load and compile correct template', function() {\n     *       element(by.linkText('Moby: Ch1')).click();\n     *       var content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: ChapterController/);\n     *       expect(content).toMatch(/Book Id: Moby/);\n     *       expect(content).toMatch(/Chapter Id: 1/);\n     *\n     *       element(by.partialLinkText('Scarlet')).click();\n     *\n     *       content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller: BookController/);\n     *       expect(content).toMatch(/Book Id: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route change has happened successfully.\n     * The `resolve` dependencies are now available in the `current.locals` property.\n     *\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if a redirection function fails or any redirection or resolve promises are\n     * rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection The thrown error or the rejection reason of the promise. Usually\n     * the rejection reason is the error that caused the promise to get rejected.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if the same instance of a route (including template, controller instance,\n     * resolved dependencies, etc.) is being reused. This can happen if either `reloadOnSearch` or\n     * `reloadOnUrl` has been set to `false`.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current/previous route information.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n\n            var fakeLocationEvent = {\n              defaultPrevented: false,\n              preventDefault: function fakePreventDefault() {\n                this.defaultPrevented = true;\n                forceReload = false;\n              }\n            };\n\n            $rootScope.$evalAsync(function() {\n              prepareRoute(fakeLocationEvent);\n              if (!fakeLocationEvent.defaultPrevented) commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route's path segment\n           * definitions will be interpolated into the location's path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr('norout', 'Tried updating route with no current route');\n            }\n          }\n        };\n\n    $rootScope.$on('$locationChangeStart', prepareRoute);\n    $rootScope.$on('$locationChangeSuccess', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = isNavigationUpdateOnly(preparedRoute, lastRoute);\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n\n        var nextRoutePromise = $q.resolve(nextRoute);\n\n        $browser.$$incOutstandingRequestCount('$route');\n\n        nextRoutePromise.\n          then(getRedirectionData).\n          then(handlePossibleRedirection).\n          then(function(keepProcessingRoute) {\n            return keepProcessingRoute && nextRoutePromise.\n              then(resolveLocals).\n              then(function(locals) {\n                // after route change\n                if (nextRoute === $route.current) {\n                  if (nextRoute) {\n                    nextRoute.locals = locals;\n                    angular.copy(nextRoute.params, $routeParams);\n                  }\n                  $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);\n                }\n              });\n          }).catch(function(error) {\n            if (nextRoute === $route.current) {\n              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);\n            }\n          }).finally(function() {\n            // Because `commitRoute()` is called from a `$rootScope.$evalAsync` block (see\n            // `$locationWatch`), this `$$completeOutstandingRequest()` call will not cause\n            // `outstandingRequestCount` to hit zero.  This is important in case we are redirecting\n            // to a new route which also requires some asynchronous work.\n\n            $browser.$$completeOutstandingRequest(noop, '$route');\n          });\n      }\n    }\n\n    function getRedirectionData(route) {\n      var data = {\n        route: route,\n        hasRedirection: false\n      };\n\n      if (route) {\n        if (route.redirectTo) {\n          if (angular.isString(route.redirectTo)) {\n            data.path = interpolate(route.redirectTo, route.params);\n            data.search = route.params;\n            data.hasRedirection = true;\n          } else {\n            var oldPath = $location.path();\n            var oldSearch = $location.search();\n            var newUrl = route.redirectTo(route.pathParams, oldPath, oldSearch);\n\n            if (angular.isDefined(newUrl)) {\n              data.url = newUrl;\n              data.hasRedirection = true;\n            }\n          }\n        } else if (route.resolveRedirectTo) {\n          return $q.\n            resolve($injector.invoke(route.resolveRedirectTo)).\n            then(function(newUrl) {\n              if (angular.isDefined(newUrl)) {\n                data.url = newUrl;\n                data.hasRedirection = true;\n              }\n\n              return data;\n            });\n        }\n      }\n\n      return data;\n    }\n\n    function handlePossibleRedirection(data) {\n      var keepProcessingRoute = true;\n\n      if (data.route !== $route.current) {\n        keepProcessingRoute = false;\n      } else if (data.hasRedirection) {\n        var oldUrl = $location.url();\n        var newUrl = data.url;\n\n        if (newUrl) {\n          $location.\n            url(newUrl).\n            replace();\n        } else {\n          newUrl = $location.\n            path(data.path).\n            search(data.search).\n            replace().\n            url();\n        }\n\n        if (newUrl !== oldUrl) {\n          // Exit out and don't process current next value,\n          // wait for next location change from redirect\n          keepProcessingRoute = false;\n        }\n      }\n\n      return keepProcessingRoute;\n    }\n\n    function resolveLocals(route) {\n      if (route) {\n        var locals = angular.extend({}, route.resolve);\n        angular.forEach(locals, function(value, key) {\n          locals[key] = angular.isString(value) ?\n              $injector.get(value) :\n              $injector.invoke(value, null, null, key);\n        });\n        var template = getTemplateFor(route);\n        if (angular.isDefined(template)) {\n          locals['$template'] = template;\n        }\n        return $q.all(locals);\n      }\n    }\n\n    function getTemplateFor(route) {\n      var template, templateUrl;\n      if (angular.isDefined(template = route.template)) {\n        if (angular.isFunction(template)) {\n          template = template(route.params);\n        }\n      } else if (angular.isDefined(templateUrl = route.templateUrl)) {\n        if (angular.isFunction(templateUrl)) {\n          templateUrl = templateUrl(route.params);\n        }\n        if (angular.isDefined(templateUrl)) {\n          route.loadedTemplateUrl = $sce.valueOf(templateUrl);\n          template = $templateRequest(templateUrl);\n        }\n      }\n      return template;\n    }\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @param {Object} newRoute - The new route configuration (as returned by `parseRoute()`).\n     * @param {Object} oldRoute - The previous route configuration (as returned by `parseRoute()`).\n     * @returns {boolean} Whether this is an \"update-only\" navigation, i.e. the URL maps to the same\n     *                    route and it can be reused (based on the config and the type of change).\n     */\n    function isNavigationUpdateOnly(newRoute, oldRoute) {\n      // IF this is not a forced reload\n      return !forceReload\n          // AND both `newRoute`/`oldRoute` are defined\n          && newRoute && oldRoute\n          // AND they map to the same Route Definition Object\n          && (newRoute.$$route === oldRoute.$$route)\n          // AND `reloadOnUrl` is disabled\n          && (!newRoute.reloadOnUrl\n              // OR `reloadOnSearch` is disabled\n              || (!newRoute.reloadOnSearch\n                  // AND both routes have the same path params\n                  && angular.equals(newRoute.pathParams, oldRoute.pathParams)\n              )\n          );\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || '').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\ninstantiateRoute.$inject = ['$injector'];\nfunction instantiateRoute($injector) {\n  if (isEagerInstantiationEnabled) {\n    // Instantiate `$route`\n    $injector.get('$route');\n  }\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n * @this\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\nngRouteModule.directive('ngView', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * | Animation                        | Occurs                              |\n * |----------------------------------|-------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from to the DOM  |\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name=\"ngView-directive\" module=\"ngViewExample\"\n             deps=\"angular-route.js;angular-animate.js\"\n             animations=\"true\" fixBase=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCtrl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"view-animate-container\">\n            <div ng-view class=\"view-animate\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])\n          .config(['$routeProvider', '$locationProvider',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when('/Book/:bookId', {\n                  templateUrl: 'book.html',\n                  controller: 'BookCtrl',\n                  controllerAs: 'book'\n                })\n                .when('/Book/:bookId/ch/:chapterId', {\n                  templateUrl: 'chapter.html',\n                  controller: 'ChapterCtrl',\n                  controllerAs: 'chapter'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller('MainCtrl', ['$route', '$routeParams', '$location',\n            function MainCtrl($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller('BookCtrl', ['$routeParams', function BookCtrl($routeParams) {\n            this.name = 'BookCtrl';\n            this.params = $routeParams;\n          }])\n          .controller('ChapterCtrl', ['$routeParams', function ChapterCtrl($routeParams) {\n            this.name = 'ChapterCtrl';\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name=\"protractor.js\" type=\"protractor\">\n        it('should load and compile correct template', function() {\n          element(by.linkText('Moby: Ch1')).click();\n          var content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: ChapterCtrl/);\n          expect(content).toMatch(/Book Id: Moby/);\n          expect(content).toMatch(/Chapter Id: 1/);\n\n          element(by.partialLinkText('Scarlet')).click();\n\n          content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller: BookCtrl/);\n          expect(content).toMatch(/Book Id: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.done(function(response) {\n              if (response !== false) previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can't remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).done(function onNgViewEnter(response) {\n                if (response !== false && angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data('$ngControllerController', controller);\n        $element.children().data('$ngControllerController', controller);\n      }\n      scope[current.resolveAs || '$resolve'] = locals;\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);\n"],"names":["window","angular","routeToRegExp","path","opts","keys","pattern","replace","_","slash","key","option","optional","star","push","name","ignoreTrailingSlashes","regexp","RegExp","caseInsensitiveMatch","isArray","isObject","isDefined","noop","isEagerInstantiationEnabled","ngRouteModule","module","info","angularVersion","provider","inherit","parent","extra","extend","Object","create","routes","this","when","route","routeCopy","src","dst","i","ii","length","charAt","shallowCopy","isUndefined","reloadOnUrl","reloadOnSearch","originalPath","redirectPath","substr","redirectTo","otherwise","params","eagerInstantiationEnabled","enabled","$get","$rootScope","$location","$routeParams","$q","$injector","$templateRequest","$sce","$browser","preparedRoute","preparedRouteIsUpdateOnly","forceReload","$route","reload","fakeLocationEvent","defaultPrevented","preventDefault","$evalAsync","prepareRoute","commitRoute","updateParams","newParams","current","$$route","$routeMinErr","interpolate","search","$locationEvent","match","newRoute","oldRoute","lastRoute","forEach","on","m","exec","len","val","switchRouteMatcher","pathParams","equals","$broadcast","nextRoute","copy","nextRoutePromise","resolve","$$incOutstandingRequestCount","then","getRedirectionData","handlePossibleRedirection","keepProcessingRoute","resolveLocals","locals","catch","error","finally","$$completeOutstandingRequest","data","hasRedirection","isString","oldPath","oldSearch","newUrl","url","resolveRedirectTo","invoke","oldUrl","value","get","template","templateUrl","isFunction","loadedTemplateUrl","valueOf","getTemplateFor","all","string","result","split","segment","segmentMatch","join","$on","run","instantiateRoute","$$minErr","ngViewFactory","$anchorScroll","$animate","restrict","terminal","priority","transclude","link","scope","$element","attr","ctrl","$transclude","currentScope","currentElement","previousLeaveAnimation","autoScrollExp","autoscroll","onloadExp","onload","cleanupLastView","cancel","$destroy","leave","done","response","update","$template","newScope","$new","clone1","clone","enter","$eval","$emit","ngViewFillContentFactory","$compile","$controller","html","contents","controller","$scope","controllerAs","children","resolveAs","$inject","directive"],"version":3,"file":"privacy-seoflow.31e8186f.js.map"}